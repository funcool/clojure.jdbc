<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>jdbc documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clj.jdbc 0.1.0-beta5 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="jdbc.html"><span>jdbc</span></a></li><li><a href="jdbc.pool.html"><span>jdbc.pool</span></a></li><li><a href="jdbc.pool.c3p0.html"><span>jdbc.pool.c3p0</span></a></li><li><a href="jdbc.transaction.html"><span>jdbc.transaction</span></a></li><li><a href="jdbc.types.html"><span>jdbc.types</span></a></li><li><a href="jdbc.types.connection.html"><span>jdbc.types.connection</span></a></li><li><a href="jdbc.types.resultset.html"><span>jdbc.types.resultset</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="jdbc.html#var-execute%21"><span>execute!</span></a></li><li><a href="jdbc.html#var-execute-prepared%21"><span>execute-prepared!</span></a></li><li><a href="jdbc.html#var-execute-statement%21"><span>execute-statement!</span></a></li><li><a href="jdbc.html#var-make-connection"><span>make-connection</span></a></li><li><a href="jdbc.html#var-make-prepared-statement"><span>make-prepared-statement</span></a></li><li><a href="jdbc.html#var-make-query"><span>make-query</span></a></li><li><a href="jdbc.html#var-map-%3Eproperties"><span>map-&gt;properties</span></a></li><li><a href="jdbc.html#var-query"><span>query</span></a></li><li><a href="jdbc.html#var-result-set-%3Elazyseq"><span>result-set-&gt;lazyseq</span></a></li><li><a href="jdbc.html#var-result-set-%3Evector"><span>result-set-&gt;vector</span></a></li><li><a href="jdbc.html#var-uri-%3Edbspec"><span>uri-&gt;dbspec</span></a></li><li><a href="jdbc.html#var-with-connection"><span>with-connection</span></a></li><li><a href="jdbc.html#var-with-query"><span>with-query</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>jdbc documentation</h2><pre class="doc">Alternative implementation of jdbc wrapper for clojure.
</pre><div class="public" id="var-execute%21"><h3>execute!</h3><div class="usage"><code>(execute! conn &amp; commands)</code></div><pre class="doc">Run arbitrary number of raw sql commands such as: CREATE TABLE,
DROP TABLE, etc... If your want transactions, you can wrap this
call in transaction using `with-transaction` context block macro
that is available in  ``jdbc.transaction`` namespace.

Warning: not all database servers support ddl in transactions.

Examples:

  ;; Without transactions
  (with-connection dbspec conn
    (execute! conn 'CREATE TABLE foo (id serial, name text);'))

  ;; In one transaction
  (with-connection dbspec conn
    (tx/with-transaction conn
      (execute! conn 'CREATE TABLE foo (id serial, name text);')))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L198">Source</a></div></div><div class="public" id="var-execute-prepared%21"><h3>execute-prepared!</h3><div class="usage"><code>(execute-prepared! conn sql &amp; param-groups)</code></div><pre class="doc">Same as `execute!` function, but works with PreparedStatement
instead with plain Statement.

With this you can execute multiple operations throught
one call, such as bulk update.

Example:

  (with-connection dbspec conn
    (let [sql 'UPDATE TABLE foo SET x = ? WHERE y = ?;']
      (execute-prepared! conn sql [1 2] [2 3] [3 4])))

  This code should send this sql sentences:

    UPDATE TABLE foo SET x = 1 WHERE y = 2;
    UPDATE TABLE foo SET x = 2 WHERE y = 3;
    UPDATE TABLE foo SET x = 3 WHERE y = 4;
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L225">Source</a></div></div><div class="public" id="var-execute-statement%21"><h3>execute-statement!</h3><div class="usage"><code>(execute-statement! stmt)</code></div><pre class="doc">Given a plain statement instance, execute it throught its asociated
connection and return a raw seq of results.

This is a low level interface and should be used with precaution. This
function is used internally for execue raw sql such as CREATE/DROP
table.

Status: Alpha - Implementation and name of this method can change on
following versions.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L122">Source</a></div></div><div class="public" id="var-make-connection"><h3>make-connection</h3><div class="usage"><code>(make-connection {:keys [connection-uri subprotocol subname datasource user password read-only schema], :or {read-only false, schema nil}, :as dbspec})</code></div><pre class="doc">Creates a connection to a database.

Here some simple examples, but if you want more detailed information,
please read a documentation:

  ;; Using a plain dbspec
  (with-open [c (make-connection {:subprotocol &quot;h2&quot; :subname &quot;mem:&quot;})]
    (do-somethin-with-connection c))

  ;; Using raw jdbc connection url
  (with-open [c (make-connection &quot;postgresql://user:pass@localhost/test&quot;)]
    (do-somethin-with-connection c))</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L164">Source</a></div></div><div class="public" id="var-make-prepared-statement"><h3>make-prepared-statement</h3><div class="usage"><code>(make-prepared-statement conn sqlvec)</code><code>(make-prepared-statement conn sqlvec {:keys [result-type result-concurency fetch-size max-rows holdability lazy], :or {result-type :forward-only, result-concurency :read-only, fetch-size 100}, :as options})</code></div><pre class="doc">Given connection and parametrized query as vector with first
argument as string and other arguments as params, return a
prepared statement.

Example:

  (let [stmt (make-prepared-statement conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (println (instance? java.sql.PreparedStatement stmt)))
  ;; -&gt; true
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L253">Source</a></div></div><div class="public" id="var-make-query"><h3>make-query</h3><div class="usage"><code>(make-query conn sql-with-params)</code><code>(make-query conn sql-with-params {:keys [fetch-size lazy], :or {lazy false}, :as options})</code></div><pre class="doc">Given a connection and paramatrized sql, execute a query and
return a instance of ResultSet that works as stantard clojure
map but implements a closable interface.

A returned ``jdbc.types.resultset.ResultSet`` works as a wrapper
around a prepared statement and java.sql.ResultSet mostly used for
server side cursors properly resource management.

This functions indents be a low level access for making queries
and it delegate to a user the resource management.

NOTE: It strongly recommended not use this function directly and use a ``with-query``
macro for make query thar returns large amount of data or simple ``query`` function
that returns directly a evaluated result.

Example using parametrized sql:

  (with-open [result (make-query conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (doseq [row (:data result)]
      (println row)))

Example using plain sql (without parameters):

  (with-open [result (make-query conn &quot;SELECT version();&quot;)]
    (doseq [row (:data result)]
      (println row)))

Example using extern prepared statement:

  (let [stmt (make-prepared-statement conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (with-open [result (make-query conn stmt)]
      (doseq [row (:data result)]
        (println row))))</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L306">Source</a></div></div><div class="public" id="var-map-%3Eproperties"><h3>map-&gt;properties</h3><div class="usage"><code>(map-&gt;properties data)</code></div><pre class="doc">Convert hash-map to java.utils.Properties instance. This method is used
internally for convert dbspec map to properties instance, but it can
be usefull for other purposes.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L36">Source</a></div></div><div class="public" id="var-query"><h3>query</h3><div class="usage"><code>(query conn sqlvec)</code><code>(query conn sqlvec options)</code></div><pre class="doc">Perform a simple sql query and return a evaluated result as vector.

``sqlvec`` parameter can be: parametrized sql (vector format), plain sql
(simple sql string) or prepared statement instance.

Example using parametrized sql:

  (doseq [row (query conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (println row))

Example using plain sql (without parameters):

  (doseq [row (query conn &quot;SELECT version();&quot;)]
    (println row))

Example using extern prepared statement:

  (let [stmt (make-prepared-statement conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (doseq [row (query conn stmt)]
      (println row)))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L350">Source</a></div></div><div class="public" id="var-result-set-%3Elazyseq"><h3>result-set-&gt;lazyseq</h3><div class="usage"><code>(result-set-&gt;lazyseq conn rs &amp; [{:keys [identifiers as-rows?], :or {identifiers str/lower-case, as-rows? false}, :as options}])</code></div><pre class="doc">Function that wraps result in a lazy seq. This function
is part of public api but can not be used directly (you should pass
this function as parameter to `query` function).

Required parameters:
  rs: ResultSet instance.

Optional named parameters:
  :identifiers -&gt; function that is applied for column name
                  when as-arrays? is false
  :as-rows?    -&gt; by default this function return a lazy seq of
                  records (map), but in certain circumstances you
                  need results as a lazy-seq of vectors. With this keywork
                  parameter you can enable this behavior and return a lazy-seq
                  of vectors instead of records (maps).
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L82">Source</a></div></div><div class="public" id="var-result-set-%3Evector"><h3>result-set-&gt;vector</h3><div class="usage"><code>(result-set-&gt;vector &amp; args)</code></div><pre class="doc">Function that evaluates a result into one clojure persistent
vector. Accept same parameters as `result-set-&gt;lazyseq`.</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L116">Source</a></div></div><div class="public" id="var-uri-%3Edbspec"><h3>uri-&gt;dbspec</h3><div class="usage"><code>(uri-&gt;dbspec url)</code></div><pre class="doc">Parses a dbspec as uri into a plain dbspec. This function
accepts ``java.net.URI`` or ``String`` as parameter.</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L52">Source</a></div></div><div class="public" id="var-with-connection"><h3>with-connection</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-connection dbspec bindname &amp; body)</code></div><pre class="doc">Given database connection paramers (dbspec), creates
a context with new connection to database that are closed
at end of code block.

If dbspec has datasource (connection pool), instead of create
a new connection, get it from connection pool and release it
at the end.

Example:

  (with-connection dbspec conn
    (do-something-with conn))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L399">Source</a></div></div><div class="public" id="var-with-query"><h3>with-query</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-query conn bindname sqlvec &amp; body)</code></div><pre class="doc">Idiomatic dsl macro for ``query`` function that handles well queries
what returns a huge amount of results.

``sqlvec`` can be in same formats as in ``query`` function.

NOTE: This method ensueres a query in one implicit transaction.

Example:

  (with-query conn results
    [&quot;SELECT name FROM people WHERE id = ?&quot; 1]
    (doseq [row results]
      (println row)))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L378">Source</a></div></div></div></body></html>