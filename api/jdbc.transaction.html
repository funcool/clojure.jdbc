<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>jdbc.transaction documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clojure.jdbc 0.2.0-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="jdbc.html"><span>jdbc</span></a></li><li><a href="jdbc.constants.html"><span>jdbc.constants</span></a></li><li><a href="jdbc.pool.html"><span>jdbc.pool</span></a></li><li class="current"><a href="jdbc.transaction.html"><span>jdbc.transaction</span></a></li><li><a href="jdbc.types.html"><span>jdbc.types</span></a></li><li><a href="jdbc.types.connection.html"><span>jdbc.types.connection</span></a></li><li><a href="jdbc.types.resultset.html"><span>jdbc.types.resultset</span></a></li><li><a href="jdbc.util.html"><span>jdbc.util</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="jdbc.transaction.html#var--%3EDefaultTransactionStrategy"><span>-&gt;DefaultTransactionStrategy</span></a></li><li><a href="jdbc.transaction.html#var-ITransactionStrategy"><span>ITransactionStrategy</span></a></li><li><a href="jdbc.transaction.html#var-begin%21"><span>begin!</span></a></li><li><a href="jdbc.transaction.html#var-call-in-transaction"><span>call-in-transaction</span></a></li><li><a href="jdbc.transaction.html#var-commit%21"><span>commit!</span></a></li><li><a href="jdbc.transaction.html#var-is-rollback-set%3F"><span>is-rollback-set?</span></a></li><li><a href="jdbc.transaction.html#var-map-%3EDefaultTransactionStrategy"><span>map-&gt;DefaultTransactionStrategy</span></a></li><li><a href="jdbc.transaction.html#var-rollback%21"><span>rollback!</span></a></li><li><a href="jdbc.transaction.html#var-set-rollback%21"><span>set-rollback!</span></a></li><li><a href="jdbc.transaction.html#var-unset-rollback%21"><span>unset-rollback!</span></a></li><li><a href="jdbc.transaction.html#var-with-transaction"><span>with-transaction</span></a></li><li><a href="jdbc.transaction.html#var-with-transaction-strategy"><span>with-transaction-strategy</span></a></li><li><a href="jdbc.transaction.html#var-wrap-transaction-strategy"><span>wrap-transaction-strategy</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>jdbc.transaction documentation</h2><pre class="doc">Transactions support for clojure.jdbc
</pre><div class="public" id="var--%3EDefaultTransactionStrategy"><h3>-&gt;DefaultTransactionStrategy</h3><div class="usage"><code>(-&gt;DefaultTransactionStrategy)</code></div><pre class="doc">Positional factory function for class jdbc.transaction.DefaultTransactionStrategy.
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L26">Source</a></div></div><div class="public" id="var-ITransactionStrategy"><h3>ITransactionStrategy</h3><div class="usage"></div><pre class="doc"></pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L21">Source</a></div></div><div class="public" id="var-begin%21"><h3>begin!</h3><div class="usage"><code>(begin! _ conn opts)</code></div><pre class="doc">Starts a transaction and return a connection instance
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/#L">Source</a></div></div><div class="public" id="var-call-in-transaction"><h3>call-in-transaction</h3><div class="usage"><code>(call-in-transaction conn func &amp; [{:keys [savepoints strategy], :or {savepoints true}, :as opts}])</code></div><pre class="doc">Wrap function in one transaction.
This function accepts as a parameter a transaction strategy. If no one
is specified, ``DefaultTransactionStrategy`` is used.

With `DefaultTransactionStrategy`, if current connection is already in
transaction, it uses truly nested transactions for properly handle it.
The availability of this feature depends on database support for it.

Example:

(with-connection dbspec conn
  (call-in-transaction conn (fn [conn] (execute! conn 'DROP TABLE foo;'))))

For more idiomatic code, you should use `with-transaction` macro.

Depending on transaction strategy you are using, this function can accept
additional parameters. The default transaction strategy exposes two additional
parameters:

- `:isolation-level` - set isolation level for this transaction
- `:read-only` - set current transaction to read only</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L139">Source</a></div></div><div class="public" id="var-commit%21"><h3>commit!</h3><div class="usage"><code>(commit! _ conn opts)</code></div><pre class="doc">Commits a transaction. Returns nil.
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/#L">Source</a></div></div><div class="public" id="var-is-rollback-set%3F"><h3>is-rollback-set?</h3><div class="usage"><code>(is-rollback-set? conn)</code></div><pre class="doc">Check if a current connection in one transaction
is marked for rollback.

This should be used in one transaction, in other case this
function always return false.</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L127">Source</a></div></div><div class="public" id="var-map-%3EDefaultTransactionStrategy"><h3>map-&gt;DefaultTransactionStrategy</h3><div class="usage"><code>(map-&gt;DefaultTransactionStrategy m__5869__auto__)</code></div><pre class="doc">Factory function for class jdbc.transaction.DefaultTransactionStrategy, taking a map of keywords to field values.
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L26">Source</a></div></div><div class="public" id="var-rollback%21"><h3>rollback!</h3><div class="usage"><code>(rollback! _ conn opts)</code></div><pre class="doc">Rollbacks a transaction. Returns nil.
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/#L">Source</a></div></div><div class="public" id="var-set-rollback%21"><h3>set-rollback!</h3><div class="usage"><code>(set-rollback! conn)</code></div><pre class="doc">Mark a current connection for rollback.

It ensures that on the end of the current transaction
instead of commit changes, rollback them.

This function should be used inside of a transaction
block, otherwise this function does nothing.

Example:

(with-transaction conn
  (make-some-queries-without-changes conn)
  (set-rollback! conn))</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L98">Source</a></div></div><div class="public" id="var-unset-rollback%21"><h3>unset-rollback!</h3><div class="usage"><code>(unset-rollback! conn)</code></div><pre class="doc">Revert flag setted by `set-rollback!` function.
This function should be used inside of a transaction
block, otherwise this function does nothing.</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L118">Source</a></div></div><div class="public" id="var-with-transaction"><h3>with-transaction</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-transaction conn &amp; body)</code></div><pre class="doc">Creates a context that evaluates in transaction (or nested transaction).
This is a more idiomatic way to execute some database operations in
atomic way.

Example:

(with-transaction conn
  (execute! conn 'DROP TABLE foo;')
  (execute! conn 'DROP TABLE bar;'))

Also, you can pass additional options to transaction:

(with-transaction conn {:read-only true}
  (execute! conn 'DROP TABLE foo;')
  (execute! conn 'DROP TABLE bar;'))</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L188">Source</a></div></div><div class="public" id="var-with-transaction-strategy"><h3>with-transaction-strategy</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-transaction-strategy conn strategy &amp; body)</code></div><pre class="doc">Set some transaction strategy connection in the current context scope.
This method not uses thread-local dynamic variables and connection
preserves a transaction strategy throught threads.</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L180">Source</a></div></div><div class="public" id="var-wrap-transaction-strategy"><h3>wrap-transaction-strategy</h3><div class="usage"><code>(wrap-transaction-strategy conn strategy)</code></div><pre class="doc">Simple helper function that associate a strategy
to a connection and return a new connection object
with wrapped stragy.

Example:

(let [conn (wrap-transaction-strategy simplecon (MyStrategy.))]
  (use-your-new-conn conn))</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L85">Source</a></div></div></div></body></html>